From 302695af78b2814e8c2a08916e49e0f2bd8c9a3f Mon Sep 17 00:00:00 2001
From: jakub <jakub@138bc75d-0d04-0410-961f-82ee72b054a4>
Date: Thu, 15 May 2014 10:08:12 +0000
Subject: [PATCH] 	PR tree-optimization/61158
 	* fold-const.c (fold_binary_loc): If X is zero-extended and
 	shiftc >= prec, make sure zerobits is all ones instead of
 	invoking undefined behavior.

	* gcc.dg/pr61158.c: New test.


git-svn-id: svn+ssh://gcc.gnu.org/svn/gcc/branches/gcc-4_9-branch@210469 138bc75d-0d04-0410-961f-82ee72b054a4
---
 gcc/ChangeLog                  |    7 +++++++
 gcc/fold-const.c               |   12 +++++++++---
 gcc/testsuite/ChangeLog        |    5 +++++
 gcc/testsuite/gcc.dg/pr61158.c |   12 ++++++++++++
 4 files changed, 33 insertions(+), 3 deletions(-)
 create mode 100644 gcc/testsuite/gcc.dg/pr61158.c

diff --git a/gcc/ChangeLog b/gcc/ChangeLog
index 9b4929b..33d9eec 100644
--- a/gcc/ChangeLog
+++ b/gcc/ChangeLog
@@ -1,3 +1,10 @@
+2014-05-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/61158
+	* fold-const.c (fold_binary_loc): If X is zero-extended and
+	shiftc >= prec, make sure zerobits is all ones instead of
+	invoking undefined behavior.
+
 2014-05-14  Cary Coutant  <ccoutant@google.com>
 
         PR debug/61013
diff --git a/gcc/fold-const.c b/gcc/fold-const.c
index 5c2bf25..c8156af 100644
--- a/gcc/fold-const.c
+++ b/gcc/fold-const.c
@@ -12088,11 +12088,17 @@ fold_binary_loc (location_t loc,
 		      /* See if we can shorten the right shift.  */
 		      if (shiftc < prec)
 			shift_type = inner_type;
+		      /* Otherwise X >> C1 is all zeros, so we'll optimize
+			 it into (X, 0) later on by making sure zerobits
+			 is all ones.  */
 		    }
 		}
 	      zerobits = ~(unsigned HOST_WIDE_INT) 0;
-	      zerobits >>= HOST_BITS_PER_WIDE_INT - shiftc;
-	      zerobits <<= prec - shiftc;
+	      if (shiftc < prec)
+		{
+		  zerobits >>= HOST_BITS_PER_WIDE_INT - shiftc;
+		  zerobits <<= prec - shiftc;
+		}
 	      /* For arithmetic shift if sign bit could be set, zerobits
 		 can contain actually sign bits, so no transformation is
 		 possible, unless MASK masks them all away.  In that
@@ -12110,7 +12116,7 @@ fold_binary_loc (location_t loc,
 	  /* ((X << 16) & 0xff00) is (X, 0).  */
 	  if ((mask & zerobits) == mask)
 	    return omit_one_operand_loc (loc, type,
-				     build_int_cst (type, 0), arg0);
+					 build_int_cst (type, 0), arg0);
 
 	  newmask = mask | zerobits;
 	  if (newmask != mask && (newmask & (newmask + 1)) == 0)
diff --git a/gcc/testsuite/ChangeLog b/gcc/testsuite/ChangeLog
index 1047030..618e9c9 100644
--- a/gcc/testsuite/ChangeLog
+++ b/gcc/testsuite/ChangeLog
@@ -1,3 +1,8 @@
+2014-05-15  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/61158
+	* gcc.dg/pr61158.c: New test.
+
 2014-05-14  Matthias Klose  <doko@ubuntu.com>
 
 	PR driver/61106
diff --git a/gcc/testsuite/gcc.dg/pr61158.c b/gcc/testsuite/gcc.dg/pr61158.c
new file mode 100644
index 0000000..d0ba7f3
--- /dev/null
+++ b/gcc/testsuite/gcc.dg/pr61158.c
@@ -0,0 +1,12 @@
+/* PR tree-optimization/61158 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -fdump-tree-original" } */
+
+unsigned long long
+foo (unsigned int x)
+{
+  return ((unsigned long long) x & 0x00ff000000000000ULL) >> 40;
+}
+
+/* { dg-final { scan-tree-dump "return 0;" "original" { target { ilp32 || lp64 } } } } */
+/* { dg-final { cleanup-tree-dump "original" } } */
-- 
1.7.1

