From 0ff1bdd64043e43ad9ce024164163d5d9f18dbf2 Mon Sep 17 00:00:00 2001
From: Paolo Valente <paolo.valente@unimore.it>
Date: Sun, 11 May 2014 11:47:01 +0200
Subject: [PATCH] block: Switch from BFQ-v7r3 to BFQ-v7r4

. BUGFIX: Removed the check on NCQ capability before incrementing or
  decrementing counters related to the throughput-boosting mechanism
  used in case of NCQ-capable drives. In fact, the NCQ detection logic
  may cause the value of the associated variable to fluctuate, therefore
  leading to asymmetric increments or decrements.
. IMPROVEMENT: Removed a redundant condition from the logical expression
  used to establish whether a queue must benefit from idling.

Signed-off-by: Paolo Valente <paolo.valente@unimore.it>
Signed-off-by: Arianna Avanzini <avanzini.arianna@gmail.com>
---
 block/bfq-iosched.c | 11 +++++------
 block/bfq-sched.c   |  4 ++--
 block/bfq.h         | 11 +++++++----
 3 files changed, 14 insertions(+), 12 deletions(-)

diff --git a/block/bfq-iosched.c b/block/bfq-iosched.c
index 120fa08..61f2c30 100644
--- a/block/bfq-iosched.c
+++ b/block/bfq-iosched.c
@@ -1949,7 +1949,7 @@ static void bfq_bfqq_expire(struct bfq_data *bfqd,
 	if (BFQQ_SEEKY(bfqq) && reason == BFQ_BFQQ_BUDGET_TIMEOUT &&
 	    !bfq_bfqq_constantly_seeky(bfqq)) {
 		bfq_mark_bfqq_constantly_seeky(bfqq);
-		if (!blk_queue_nonrot(bfqq->bfqd->queue) && bfqd->hw_tag)
+		if (!blk_queue_nonrot(bfqd->queue))
 			bfqd->const_seeky_busy_in_flight_queues++;
 	}
 
@@ -2201,8 +2201,7 @@ static inline bool bfq_bfqq_must_idle(struct bfq_queue *bfqq)
 	struct bfq_data *bfqd = bfqq->bfqd;
 
 	return RB_EMPTY_ROOT(&bfqq->sort_list) && bfqd->bfq_slice_idle != 0 &&
-	       bfq_bfqq_must_not_expire(bfqq) &&
-	       !bfq_queue_nonrot_noidle(bfqd, bfqq);
+	       bfq_bfqq_must_not_expire(bfqq);
 }
 
 /*
@@ -2936,7 +2935,7 @@ static void bfq_rq_enqueued(struct bfq_data *bfqd, struct bfq_queue *bfqq,
 	bfq_update_io_seektime(bfqd, bfqq, rq);
 	if (!BFQQ_SEEKY(bfqq) && bfq_bfqq_constantly_seeky(bfqq)) {
 		bfq_clear_bfqq_constantly_seeky(bfqq);
-		if (!blk_queue_nonrot(bfqq->bfqd->queue) && bfqd->hw_tag) {
+		if (!blk_queue_nonrot(bfqd->queue)) {
 			BUG_ON(!bfqd->const_seeky_busy_in_flight_queues);
 			bfqd->const_seeky_busy_in_flight_queues--;
 		}
@@ -3097,7 +3096,7 @@ static void bfq_completed_request(struct request_queue *q, struct request *rq)
 	if (!bfqq->dispatched && !bfq_bfqq_busy(bfqq)) {
 		bfq_weights_tree_remove(bfqd, &bfqq->entity,
 					&bfqd->queue_weights_tree);
-		if (!blk_queue_nonrot(bfqq->bfqd->queue) && bfqd->hw_tag) {
+		if (!blk_queue_nonrot(bfqd->queue)) {
 			BUG_ON(!bfqd->busy_in_flight_queues);
 			bfqd->busy_in_flight_queues--;
 			if (bfq_bfqq_constantly_seeky(bfqq)) {
@@ -3852,7 +3851,7 @@ static int __init bfq_init(void)
 	device_speed_thresh[1] = (R_fast[1] + R_slow[1]) / 2;
 
 	elv_register(&iosched_bfq);
-	pr_info("BFQ I/O-scheduler version: v7r3");
+	pr_info("BFQ I/O-scheduler version: v7r4");
 
 	return 0;
 }
diff --git a/block/bfq-sched.c b/block/bfq-sched.c
index daf1b4b..8428215 100644
--- a/block/bfq-sched.c
+++ b/block/bfq-sched.c
@@ -1130,7 +1130,7 @@ static void bfq_del_bfqq_busy(struct bfq_data *bfqd, struct bfq_queue *bfqq,
 	if (!bfqq->dispatched) {
 		bfq_weights_tree_remove(bfqd, &bfqq->entity,
 					&bfqd->queue_weights_tree);
-		if (!blk_queue_nonrot(bfqd->queue) && bfqd->hw_tag) {
+		if (!blk_queue_nonrot(bfqd->queue)) {
 			BUG_ON(!bfqd->busy_in_flight_queues);
 			bfqd->busy_in_flight_queues--;
 			if (bfq_bfqq_constantly_seeky(bfqq)) {
@@ -1165,7 +1165,7 @@ static void bfq_add_bfqq_busy(struct bfq_data *bfqd, struct bfq_queue *bfqq)
 		if (bfqq->wr_coeff == 1)
 			bfq_weights_tree_add(bfqd, &bfqq->entity,
 					     &bfqd->queue_weights_tree);
-		if (!blk_queue_nonrot(bfqd->queue) && bfqd->hw_tag) {
+		if (!blk_queue_nonrot(bfqd->queue)) {
 			bfqd->busy_in_flight_queues++;
 			if (bfq_bfqq_constantly_seeky(bfqq))
 				bfqd->const_seeky_busy_in_flight_queues++;
diff --git a/block/bfq.h b/block/bfq.h
index dc2f295..e1957e0 100644
--- a/block/bfq.h
+++ b/block/bfq.h
@@ -342,14 +342,17 @@ enum bfq_device_speed {
  *		 queue under service, even if it is idling).
  * @busy_in_flight_queues: number of @bfq_queues containing pending or
  *                         in-flight requests, plus the @bfq_queue in service,
- *			   even if idle but waiting for the possible arrival
- *			   of its next sync request.
+ *                         even if idle but waiting for the possible arrival
+ *                         of its next sync request; this field is used only
+ *                         for rotational devices.
  * @const_seeky_busy_in_flight_queues: number of constantly-seeky @bfq_queues
  *                                     (that is, seeky queues that expired
  *                                     for budget timeout at least once)
  *                                     containing pending or in-flight
- *					requests, including the in-service
- *					@bfq_queue if constantly seeky.
+ *                                     requests, including the in-service
+ *                                     @bfq_queue if constantly seeky; this
+ *                                     field is used only for rotational
+ *                                     devices.
  * @raised_busy_queues: number of weight-raised busy bfq_queues.
  * @queued: number of queued requests.
  * @rq_in_driver: number of requests dispatched and waiting for completion.
-- 
1.9.2

