From 60fe959e1446337c3455656daad2c2b7114a1dcd Mon Sep 17 00:00:00 2001
From: "Brian C. Lane" <bcl@redhat.com>
Date: Wed, 11 Sep 2013 12:24:53 -0700
Subject: [PATCH 70/89] libparted: use dm_udev_wait (#698121)

This is based on Peter Rajnoha's patch to use dm_udev_wait to
synchronize with udev.

This requires libdevmapper v1.02.39 and higher.

mailing list thread:
https://lists.gnu.org/archive/html/bug-parted/2010-09/msg00007.html

* libparted/arch/linux.c (_dm_task_run_wait): New function
(_is_dm_major): Add cookie and change call to _dm_task_run_wait
(_is_dmraid_device): Same
(_dm_is_part): Same
(dm_canonical_path): Same
(_dm_remove_partition): Same
(_dm_get_partition_start_and_length): Same
(_dm_add_partition): Same
(linux_new): Enable udev sync support
---
 NEWS                   |  5 +++++
 libparted/arch/linux.c | 42 +++++++++++++++++++++++++++++-------------
 2 files changed, 34 insertions(+), 13 deletions(-)

diff --git a/NEWS b/NEWS
index 40ce370..9f51f85 100644
--- a/NEWS
+++ b/NEWS
@@ -13,6 +13,11 @@ GNU parted NEWS                                    -*- outline -*-
 
 ** Bug Fixes
 
+  libparted: On multipath systems new partitions would sometimes not
+  appear, reporting 'device-mapper: create ioctl failed: Device or
+  resource busy' until the system was rebooted. Added dm_udev_wait
+  calls to synchronize parted with udev.
+
   Fix help text for disk_{set,toggle} to show *disk* flags instead
   of partition flags.
 
diff --git a/libparted/arch/linux.c b/libparted/arch/linux.c
index f43eae1..452ea7f 100644
--- a/libparted/arch/linux.c
+++ b/libparted/arch/linux.c
@@ -438,6 +438,17 @@ _is_virtblk_major (int major)
 
 #ifdef ENABLE_DEVICE_MAPPER
 static int
+_dm_task_run_wait (struct dm_task *task, uint32_t cookie)
+{
+        int rc = 0;
+
+        rc = dm_task_run (task);
+        dm_udev_wait (cookie);
+
+        return rc;
+}
+
+static int
 _is_dm_major (int major)
 {
         return _major_type_in_devices (major, "device-mapper");
@@ -1385,6 +1396,10 @@ linux_new (const char* path)
         dev->dirty = 0;
         dev->boot_dirty = 0;
 
+#ifdef ENABLE_DEVICE_MAPPER
+        dm_udev_set_sync_support(1);
+#endif
+
         if (!_device_probe_type (dev))
                 goto error_free_arch_specific;
 
@@ -2631,31 +2646,29 @@ _device_get_partition_range(PedDevice const* dev)
 static int
 _dm_remove_partition(PedDisk* disk, int partno)
 {
-        int             rc;
+        int             rc = 0;
+        uint32_t        cookie = 0;
         char            *part_name = _device_get_part_path (disk->dev, partno);
 
         int fd = open (part_name, O_RDONLY | O_EXCL);
         if (fd == -1) {
                 if (errno == ENOENT)
                         errno = ENXIO; /* nothing to remove, device already doesn't exist */
-                free (part_name);
-                return 0;
+                goto err;
         }
         close (fd);
         struct dm_task *task = dm_task_create(DM_DEVICE_REMOVE);
-        if (!task) {
-                free (part_name);
-                return 0;
-        }
+        if (!task)
+                goto err;
         dm_task_set_name (task, part_name);
-        rc = dm_task_run(task);
+        if (!dm_task_set_cookie (task, &cookie, 0))
+                goto err;
+        rc = _dm_task_run_wait (task, cookie);
         dm_task_update_nodes();
         dm_task_destroy(task);
+err:
         free (part_name);
-        if (!rc)
-                return 0;
-
-        return 1;
+        return rc;
 }
 
 static bool
@@ -2699,6 +2712,7 @@ _dm_add_partition (PedDisk* disk, const PedPartition* part)
         LinuxSpecific*  arch_specific = LINUX_SPECIFIC (disk->dev);
         char *params = NULL;
         char *vol_name = NULL;
+        uint32_t cookie = 0;
 
         /* Get map name from devicemapper */
         struct dm_task *task = dm_task_create (DM_DEVICE_INFO);
@@ -2735,7 +2749,9 @@ _dm_add_partition (PedDisk* disk, const PedPartition* part)
         dm_task_set_name (task, vol_name);
         dm_task_add_target (task, 0, part->geom.length,
                 "linear", params);
-        if (dm_task_run (task)) {
+        if (!dm_task_set_cookie (task, &cookie, 0))
+                goto err;
+        if (_dm_task_run_wait (task, cookie)) {
                 dm_task_update_nodes ();
                 dm_task_destroy (task);
                 free (params);
-- 
1.8.5.3

